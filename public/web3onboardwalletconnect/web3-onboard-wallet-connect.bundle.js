!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.web3OnboardWalletConnect=t():e.web3OnboardWalletConnect=t()}(self,(()=>(()=>{"use strict";var e,t,n,r,o={},i={};function c(e){var t=i[e];if(void 0!==t)return t.exports;var n=i[e]={id:e,loaded:!1,exports:{}};return o[e].call(n.exports,n,n.exports,c),n.loaded=!0,n.exports}c.m=o,c.amdO={},c.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return c.d(t,{a:t}),t},t=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,c.t=function(n,r){if(1&r&&(n=this(n)),8&r)return n;if("object"==typeof n&&n){if(4&r&&n.__esModule)return n;if(16&r&&"function"==typeof n.then)return n}var o=Object.create(null);c.r(o);var i={};e=e||[null,t({}),t([]),t(t)];for(var s=2&r&&n;"object"==typeof s&&!~e.indexOf(s);s=t(s))Object.getOwnPropertyNames(s).forEach((e=>i[e]=()=>n[e]));return i.default=()=>n,c.d(o,i),o},c.d=(e,t)=>{for(var n in t)c.o(t,n)&&!c.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},c.f={},c.e=e=>Promise.all(Object.keys(c.f).reduce(((t,n)=>(c.f[n](e,t),t)),[])),c.u=e=>e+".web3-onboard-wallet-connect.bundle.js",c.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),c.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n={},r="web3OnboardWalletConnect:",c.l=(e,t,o,i)=>{if(n[e])n[e].push(t);else{var s,a;if(void 0!==o)for(var h=document.getElementsByTagName("script"),d=0;d<h.length;d++){var l=h[d];if(l.getAttribute("src")==e||l.getAttribute("data-webpack")==r+o){s=l;break}}s||(a=!0,(s=document.createElement("script")).charset="utf-8",s.timeout=120,c.nc&&s.setAttribute("nonce",c.nc),s.setAttribute("data-webpack",r+o),s.src=e),n[e]=[t];var u=(t,r)=>{s.onerror=s.onload=null,clearTimeout(p);var o=n[e];if(delete n[e],s.parentNode&&s.parentNode.removeChild(s),o&&o.forEach((e=>e(r))),t)return t(r)},p=setTimeout(u.bind(null,void 0,{type:"timeout",target:s}),12e4);s.onerror=u.bind(null,s.onerror),s.onload=u.bind(null,s.onload),a&&document.head.appendChild(s)}},c.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},c.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{var e;c.g.importScripts&&(e=c.g.location+"");var t=c.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");if(n.length)for(var r=n.length-1;r>-1&&!e;)e=n[r--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),c.p=e})(),(()=>{var e={179:0};c.f.j=(t,n)=>{var r=c.o(e,t)?e[t]:void 0;if(0!==r)if(r)n.push(r[2]);else{var o=new Promise(((n,o)=>r=e[t]=[n,o]));n.push(r[2]=o);var i=c.p+c.u(t),s=new Error;c.l(i,(n=>{if(c.o(e,t)&&(0!==(r=e[t])&&(e[t]=void 0),r)){var o=n&&("load"===n.type?"missing":n.type),i=n&&n.target&&n.target.src;s.message="Loading chunk "+t+" failed.\n("+o+": "+i+")",s.name="ChunkLoadError",s.type=o,s.request=i,r[1](s)}}),"chunk-"+t,t)}};var t=(t,n)=>{var r,o,[i,s,a]=n,h=0;if(i.some((t=>0!==e[t]))){for(r in s)c.o(s,r)&&(c.m[r]=s[r]);a&&a(c)}for(t&&t(n);h<i.length;h++)o=i[h],c.o(e,o)&&e[o]&&e[o][0](),e[o]=0},n=self.webpackChunkweb3OnboardWalletConnect=self.webpackChunkweb3OnboardWalletConnect||[];n.forEach(t.bind(null,0)),n.push=t.bind(null,n.push.bind(n))})();var s={};c.r(s),c.d(s,{walletConnectModule:()=>d});const a=["eth_sendTransaction","eth_signTransaction","personal_sign","eth_sign","eth_signTypedData","eth_signTypedData_v4"],h=e=>!("string"!=typeof e||!e.match(/^0x[0-9A-Fa-f]*$/)),d=function(e){return 1===(e&&e.version||1)?function(e={version:1}){const{bridge:t="https://bridge.walletconnect.org",qrcodeModalOptions:n,connectFirstChainId:r,handleUri:o}=e||{};return()=>({label:"WalletConnect",getIcon:async()=>(await c.e(205).then(c.bind(c,2205))).default,getInterface:async({chains:e,EventEmitter:i})=>{const{StaticJsonRpcProvider:s}=await Promise.all([c.e(94),c.e(927),c.e(601)]).then(c.bind(c,6927)),{ProviderRpcError:a,ProviderRpcErrorCode:d}=await c.e(121).then(c.bind(c,7121)),{default:l}=await Promise.all([c.e(447),c.e(94),c.e(266),c.e(563)]).then(c.bind(c,8266));let u=await c.e(337).then(c.t.bind(c,4337,19));u=u.default||u;const{Subject:p,fromEvent:m}=await Promise.all([c.e(614),c.e(22)]).then(c.bind(c,5022)),{takeUntil:f,take:g}=await Promise.all([c.e(614),c.e(120)]).then(c.bind(c,120)),w=new l({bridge:t});if(o)try{await o(w.uri||"")}catch(e){throw`An error occurred when handling the URI. Error: ${e}`}const b=new i;return{provider:new class{constructor({connector:e,chains:t}){let o;this.emit=b.emit.bind(b),this.on=b.on.bind(b),this.removeListener=b.removeListener.bind(b),this.connector=e,this.chains=t,this.disconnected$=new p,this.providers={},m(this.connector,"session_update",((e,t)=>{if(e)throw e;return t})).pipe(f(this.disconnected$)).subscribe({next:({params:e})=>{const[{accounts:t,chainId:n}]=e,r=t.map((e=>e.toLowerCase()));this.emit("accountsChanged",r);const i=h(n)?n:`0x${n.toString(16)}`;o&&o===i||(this.emit("chainChanged",i),o=i)},error:console.warn}),m(this.connector,"disconnect",((e,t)=>{if(e)throw e;return t})).pipe(f(this.disconnected$)).subscribe({next:()=>{this.emit("accountsChanged",[]),this.disconnected$.next(!0),"undefined"!=typeof localStorage&&localStorage.removeItem("walletconnect")},error:console.warn}),this.disconnect=()=>this.connector.killSession(),this.request=async({method:e,params:i})=>{if("eth_chainId"===e)return h(this.connector.chainId)?this.connector.chainId:`0x${this.connector.chainId.toString(16)}`;if("eth_requestAccounts"===e)return new Promise(((e,i)=>{if(m(this.connector,"connect",((e,t)=>{if(e)throw e;return t})).pipe(g(1)).subscribe({next:({params:t})=>{const[{accounts:n,chainId:r}]=t,i=n.map((e=>e.toLowerCase()));this.emit("accountsChanged",i);const c=h(r)?r:`0x${r.toString(16)}`;o||(o=c),this.emit("chainChanged",c),u.close(),e(i)},error:i}),this.connector.connected){const{accounts:t,chainId:n}=this.connector.session,r=h(n)?n:`0x${n.toString(16)}`;this.emit("chainChanged",r),o||(o=r);const i=t.map((e=>e.toLowerCase()));return e(i)}this.connector.createSession(r?{chainId:parseInt(t[0].id,16)}:void 0).then((()=>{u.open(this.connector.uri,(()=>i(new a({code:4001,message:"User rejected the request."}))),n)}))}));if("eth_selectAccounts"===e)throw new a({code:d.UNSUPPORTED_METHOD,message:`The Provider does not support the requested method: ${e}`});if("wallet_switchEthereumChain"==e){if(!i)throw new a({code:d.INVALID_PARAMS,message:"The Provider requires a chainId to be passed in as an argument"});const e=i[0];if(!e.hasOwnProperty("chainId")||void 0===e.chainId)throw new a({code:d.INVALID_PARAMS,message:"The Provider requires a chainId to be passed in as an argument"});return this.connector.sendCustomRequest({method:"wallet_switchEthereumChain",params:[{chainId:e.chainId}]})}if("eth_sendTransaction"===e)return this.connector.sendTransaction(i[0]);if("eth_signTransaction"===e)return this.connector.signTransaction(i[0]);if("personal_sign"===e)return this.connector.signPersonalMessage(i);if("eth_sign"===e)return this.connector.signMessage(i);if(e.includes("eth_signTypedData"))return this.connector.signTypedData(i);if("eth_accounts"===e)return this.connector.sendCustomRequest({id:1337,jsonrpc:"2.0",method:e,params:i});const c=await this.request({method:"eth_chainId"});if(!this.providers[c]){const n=t.find((({id:e})=>e===c));if(!n)throw new a({code:d.CHAIN_NOT_ADDED,message:`The Provider does not have a rpcUrl to make a request for the requested method: ${e}`});this.providers[c]=new s(n.rpcUrl)}return this.providers[c].send(e,i)}}}({chains:e,connector:w})}}})}(e):function(e){if(!e||2!==e.version)throw new Error("WalletConnect requires a projectId. Please visit https://cloud.walletconnect.com to get one.");const{projectId:t,handleUri:n,requiredChains:r,qrModalOptions:o}=e;return()=>({label:"WalletConnect",getIcon:async()=>(await c.e(205).then(c.bind(c,2205))).default,getInterface:async({chains:i,EventEmitter:s,appMetadata:d})=>{const{ProviderRpcError:l,ProviderRpcErrorCode:u}=await c.e(121).then(c.bind(c,7121)),{default:p}=await Promise.all([c.e(447),c.e(620),c.e(883)]).then(c.bind(c,6620)),{Subject:m,fromEvent:f}=await Promise.all([c.e(614),c.e(22)]).then(c.bind(c,5022)),{takeUntil:g,take:w}=await Promise.all([c.e(614),c.e(120)]).then(c.bind(c,120)),b=Array.isArray(r)&&r.length&&r.every((e=>!isNaN(e)))?r.map((e=>parseInt(e))):[...i.map((({id:e})=>parseInt(e,16)))],v=await p.init({projectId:t,chains:b,metadata:(()=>{if(!d)return;const e={name:d.name,description:d.description||"",url:d.explore||d.gettingStartedGuide||"",icons:[]};return void 0!==d.icon&&d.icon.length&&(e.icons=[d.icon]),void 0!==d.logo&&d.logo.length&&(e.icons=e.icons.length?[...e.icons,d.logo]:[d.logo]),e})(),showQrModal:!0,optionalChains:i.map((({id:e})=>parseInt(e,16))),optionalMethods:a,rpcMap:i.map((({id:e,rpcUrl:t})=>({id:e,rpcUrl:t}))).reduce(((e,{id:t,rpcUrl:n})=>(e[parseInt(t,16)]=n||"",e)),{}),qrModalOptions:o}),I=new s;return{provider:new class{constructor({connector:t,chains:r}){this.emit=I.emit.bind(I),this.on=I.on.bind(I),this.removeListener=I.removeListener.bind(I),this.connector=t,this.chains=r,this.disconnected$=new m,f(this.connector,"accountsChanged",(e=>e)).pipe(g(this.disconnected$)).subscribe({next:e=>{this.emit("accountsChanged",e)},error:console.warn}),f(this.connector,"chainChanged",(e=>e)).pipe(g(this.disconnected$)).subscribe({next:e=>{const t=h(e)?e:`0x${e.toString(16)}`;this.emit("chainChanged",t)},error:console.warn}),f(this.connector,"session_delete",(e=>e)).pipe(g(this.disconnected$)).subscribe({next:()=>{this.emit("accountsChanged",[]),this.disconnected$.next(!0),"undefined"!=typeof localStorage&&localStorage.removeItem("walletconnect")},error:console.warn}),this.disconnect=()=>{this.connector.session&&this.connector.disconnect()},e&&n&&f(this.connector,"display_uri",(e=>e)).pipe(g(this.disconnected$)).subscribe((async e=>{try{n&&await n(e)}catch(e){throw`An error occurred when handling the URI. Error: ${e}`}})),(()=>{this.connector.session&&(this.emit("accountsChanged",this.connector.accounts),this.emit("chainChanged",this.connector.chainId))})(),this.request=async({method:e,params:t})=>{if("eth_chainId"===e)return h(this.connector.chainId)?this.connector.chainId:`0x${this.connector.chainId.toString(16)}`;if("eth_requestAccounts"===e)return new Promise((async(e,t)=>{if(f(this.connector,"connect",(e=>e)).pipe(w(1)).subscribe({next:({chainId:t})=>{this.emit("accountsChanged",this.connector.accounts);const n=h(t)?t:`0x${t.toString(16)}`;this.emit("chainChanged",n),e(this.connector.accounts)},error:t}),this.connector.session){const t=this.connector.accounts,n=`0x${this.connector.chainId.toString(16)}`;return this.emit("chainChanged",n),e(t)}await this.connector.connect().catch((e=>{console.error("err creating new session: ",e),t(new l({code:4001,message:"User rejected the request."}))}))}));if("eth_selectAccounts"===e)throw new l({code:u.UNSUPPORTED_METHOD,message:`The Provider does not support the requested method: ${e}`});if("wallet_switchEthereumChain"==e){if(!t)throw new l({code:u.INVALID_PARAMS,message:"The Provider requires a chainId to be passed in as an argument"});const e=t[0];if(!e.hasOwnProperty("chainId")||void 0===e.chainId)throw new l({code:u.INVALID_PARAMS,message:"The Provider requires a chainId to be passed in as an argument"});return this.connector.request({method:"wallet_switchEthereumChain",params:[{chainId:e.chainId}]})}return this.connector.request({method:e,params:t})}}}({chains:i,connector:v})}}})}(e)};return s})()));